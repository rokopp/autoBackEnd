package a_theory.question2;

public class Gradle {

    //todo
    // Since lesson 1 we've been using Gradle.
    // So, you think you know gradle?

    //todo p1
    // In your words (do not use wiki definitions)
    // What is gradle?
    // Answer: Gradle takes human written code and then in organized, structerd way, turns it into compiled .jar
    // file. With this allows to better define how you want to build code. Without the hustle of creating
    // jar file, or deploy it to a local webserver.

    //todo p2
    // What is gradle wrapper? Why are we using it instead of gradle?
    // Answer: Standardizes a project on a given Gradle version, leading to more reliable and robust builds
    // Provisioning a new Gradle version to different users and execution environment
    // (e.g. IDEs or Continuous Integration servers) is as simple as changing the Wrapper definition.
    // source: https://docs.gradle.org/current/userguide/gradle_wrapper.html

    //todo p3
    // Name at least 1 alternative to gradle
    // 1 Maven

    //todo p4
    // Name 3 different benefits or reasons for using gradle
    // 1 Gradle takes a leaf out of Maven’s book and makes common types of projects
    // — such as Java projects — easy to build by implementing conventions.
    // 2 IDE support
    // Several major IDEs allow you to import Gradle builds and interact with them: Android Studio,
    // IntelliJ IDEA, Eclipse, and NetBeans. Gradle also has support for generating the solution files
    // required to load a project into Visual Studio.
    // 3 High performance
    // Gradle avoids unnecessary work by only running the tasks that need to run
    // because their inputs or outputs have changed.
    // source: https://docs.gradle.org/current/userguide/what_is_gradle.html

}
