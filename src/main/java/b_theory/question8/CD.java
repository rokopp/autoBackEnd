package b_theory.question8;

public class CD {

    //todo A
    // What is delivery?
    // Answer: Code is checked automatically but requires human intervention to manually and strategically
    // trigger the deployment of the changes.

    //todo B
    // What makes delivery continuous?
    // Answer: Continuous Delivery is the ability to get changes of all types—including new features,
    // configuration changes, bug fixes and experiments—into production, or into the hands of users, safely and
    // quickly in a sustainable way.

    //todo C
    // In the class we had 3 stages in our CI/CD process, tick which ones stand for continuous delivery
    // [] compile
    // [] test
    // [x] deploy

    //todo D
    // Name and explain 1 benefit of CD
    // 1 Higher quality.
    // When developers have automated tools that discover regressions within minutes, teams are freed
    // to focus their effort on user research and higher level testing activities such as exploratory testing,
    // usability testing, and performance and security testing. By building a deployment pipeline, these activities
    // can be performed continuously throughout the delivery process, ensuring quality is built in to products and
    // services from the beginning.

    //todo E
    // Name and explain 1 drawback of CD
    // 1 Relying too much on automation.

    //todo F
    // Which one is more important to start with CI or CD? Why?
    // CI/CD: CI
    // Because: Easier, when I commit my code, a server automatically does something with it. Which means it can compile
    // you application, run all your tests, or even deploy to production without you lifting a finger. The benefit is
    // that you don't have to do these things yourself, as every step a human takes in the build process of an
    // application is prone to errors!
}
